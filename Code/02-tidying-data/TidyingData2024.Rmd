---
title: "Wrangling and tidying data"
author: "Erika Barthelmess"
date: "`r Sys.Date()`"
output: html_document
editor_options:
  chunk_output_type: console
---

## Introduction

Now that we've learned how to get some data into R and establish a well-organized project, *let's take a look at how to manipulate or "wrangle and tidy"* the data.

The data we will use come from [this paper](https://nsojournals.onlinelibrary.wiley.com/doi/10.1002/wlb3.01131) and can be accessed [from dryad here](https://datadryad.org/stash/dataset/doi:10.5061/dryad.4qrfj6qgx)

To wrangle data with the tidyverse, we use the `dplyr` package "verbs" via these functions:

\-`select()` grabs columns

\-`filter()` grabs rows matching particular conditions

\-`mutate()` creates new variables

\-`summarise()` provides a summary of values

\-`group_by()` allows you to use any of the above operations "by group"

If there is time, we'll also discuss reshaping a data frame with `pivot_longer()` and `pivot_wider()`.

You can learn more [here](https://dplyr.tidyverse.org/articles/dplyr.html)

## Take a look at your dataset

Start with some data

```{r}
#read in data
library(here) #here package helps "point" at file paths
DF <- read.csv(here("Data","stommel_mastertable_dryad.csv"))
```

Now get and turn on the packages we need

```{r}
#install.packages("tidyverse") #installs whole set of packages including dplyr, ggplot2, etc.
#install.packages("dplyr") #installs just dplyr package

library(dplyr) #turns on just the dplyr package
#library(tidyverse) #turns on all of the packages from the tidyverse
```

Let's look at the basic structure of our dataset

```{r}
str(DF) #output is overall structure of dataset
summary(DF)
```

## Using `select()` to grab columns

Let's grab just the columns that include the dry_season, distance_to_water and species columns using the `select()` function.

Tidyverse functions accept the data frame as their first argument, and what you want to do to the data frame as next arguments.

```{r}
select(DF, dry_season, distance_to_water, species)
```

Try using select to get just `species`, feeding type (`feed_type_A_char`) and count of individuals (`species_count`)

```{r}
select(DF, species, feed_type_A_char, species_count)
```

You can imagine that the "nestedness" could get hard to read, so an alternative is to use *piping* and the piping operator `%>%`. Every time you see the piping operator, you can substitute the words "and then" in your mind.

Thus, we can reach the same end with the following code

```{r}
DF %>% select(species, feed_type_A_char, species_count) # read as "Take DF and then select the species, feeding type and number of individuals columns from it"
```

And you can save the result as a new object if you assign it:

```{r}
Spec_counts <- DF %>% select(species, feed_type_A_char, species_count)
```

## Choose rows matching particular conditions with `filter()`

We may need to know what the values of a particular variable are in order to see which rows match a particular value. We can use `unique()` to identify those values.

How many values are there in the species variable?

```{r}
unique(DF$species)
```

And in the dry_season and feed_type_A_char variables?

```{r}
unique(DF$dry_season)
unique(DF$feed_type_A_char)
```

Now look at using `filter()` to grab rows meeting particular conditions.

Let's get all the impala

```{r}
impala <- DF %>% filter(species == "I")
```

Let's get all the mixed feeders

```{r}
DF %>% filter(feed_type_A_char == "mixed")
```

And how about all of the observations within 500m of water

```{r}
DF %>% filter(distance_to_water <= 500)
```

We can also combine terms within a `filter()`statement:

Now let's get all of the mixed feeders less than 100 m from water

```{r}
DF %>% filter(feed_type_A_char == "mixed" & distance_to_water < 100)
```

## Obtain summary values for specific subests of your data

A very common approach for getting new summary tables from your data is the combination of using the `group_by()` and `summarise()` functions together.

For example, maybe we want to know the mean distance to water observed for each species

```{r}
MeanDist <- DF %>% group_by(species) %>% summarise(
  mean_dist_water = mean(distance_to_water, na.rm = T)
)
```

We can also group by more than one variable; for each group, you will get a new column in your summary table. And we can add multiple outputs to our summarise() statement

```{r}
MeanDist <- DF %>% group_by(feed_type_A_char, species) %>% summarise(
  mean_dist_water = mean(distance_to_water, na.rm = T),
  sd_dist_water = sd(distance_to_water, na.rm = T),
  max_dist_water = max(distance_to_water, na.rm = T)
)
```

## Create new variables with `mutate()`

Let's see how we could add a new variable to the data frame. Say we want to create a new variable called "Mean_from_max" that is maximum distance to water per species minus the mean distance:

```{r}
MeanDist<- MeanDist %>% mutate(Mean_from_max = max_dist_water - mean_dist_water)
```

## Applying what you've learned

Create a new data frame from the larger data set consisting of female Douglass squirrels. Determine the mean and sd of body mass for the parental range and hybrid zone groups and save the summary results in a new data frame.

Here is a possible work-flow to answer the questions at line 133:

```{r}
DougF<-DF %>% filter(Category == "Doug" & Sex == "F") #isolates just female douglass squirrels

DougFMeans<-DougF %>% group_by(Group) %>% summarise(
  MeanMass = mean(Mass, na.rm = T),
  sdMass = sd(Mass, na.rm = T)
)
```

## If time permits, reshaping data tables.

In general, data analysis in the R framework usually wants data in what is called "long" (vs. "wide") format in which every row is a single observation and every column is a variable. Our data set is structured in that way currently. However, there are times in which certain packages require data in a "wide" format or instances in which the data come in in a wide format and need to be reshaped to long format. Reshaping of the data frame can be accomplished by two tidyverse functions, `pivot_longer()` and `pivot_wider()`

Let's look at an example.

Imagine we wanted to calculate diversity indices for the different transects in our dataset. We would first summarise the data per transect to get the list of species and count of individuals

```{r}
Sp_by_trans <- DF %>% group_by(transect_id, species) %>% summarise(
  num_animals = sum(species_count)
)
```

The `vegan` package is very useful for calculating diversity indices as well as for things like community ordination, but it requires that the data be structured with one column per species and one row per site (or transect). Let's see if we can get the data shaped in that way.

We would be going from long (one column indicating species) to wide (a new column for each species)

We use `pivot_wider()` in the `tidyr` package to do so:

```{r}
#install.packages("tidyr") #only required if you did not install whole tidyverse
library(tidyr) #turns on tidyr package. 
#library(tidyverse)
Transects_wide <- Sp_by_trans %>% pivot_wider(names_from = species, values_from = num_animals)
```

## Your Turn!

## Using `select()` to grab columns

Let's grab just the columns that include the Category, Sex and Incisor_L using the `select()` function.

Tidyverse functions accept the data frame as their first argument, and what you want to do to the data frame as next arguments.

```{r}
select(DF, Category, Sex, Incisor_L)
```

Try using select to get just Mass and Incisor_BiteForce

```{r}
select(DF, Mass, Incisor_BiteForce)
```

You can imagine that the "nestedness" could get hard to read, so an alternative is to use *piping* and the piping operator `%>%`. Every time you see the piping operator, you can subsitute the words "and then" in your mind.

Thus, we can reach the same end with the following code

```{r}
DF %>% select(Mass, Incisor_BiteForce) # read as "Take DF and then select the Mass and Incisor_BiteForce columns
```

And you can save the result as a new object if you assign it:

```{r}
BiteByMass <-DF %>% select(Mass, Incisor_BiteForce)
```

## Choose rows matching particular conditions with `filter()`

We may need to know what the values of a particular variable are in order to see which rows match a particular value. We can use `unique()` to identify those values.

How many values are there in the Category variable?

```{r}
unique(DF$Category)
```

And in the Group and Sex variables?

```{r}
unique(DF$Group)
unique(DF$Sex)
```

Now look at using `filter()` to grab rows meeting particular conditions.

Let's get all the Red squirrels

```{r}
Reds <- DF %>% filter(Category == "Red")
```

Let's get all the squirrels less than 225 grams

```{r}
DF %>% filter(Mass < 225)
```

We can also combine terms within a `filter()`statement:

Male Douglas squirrels greater than 200 grams:

```{r}
BigBoyDoug<-DF %>% filter(Sex == "M" & Category == "Doug" & Mass > 200)
```

## Create new variables with `mutate()`

Let's see how we could add a new variable to the data frame. Say we want to create a new variable called "IncisorSize" that is incisor length X incisor width:

```{r}
DF<- DF %>% mutate(IncisorSize = Incisor_L*Incisor_W)
```

Now let's get a smaller data set to work with

```{r}
MassSpeciesSex<-DF %>% select(`Museum ID`, Category, Group, Sex, Mass )
```

## Obtain summary values for specific subests of your data

A very common approach for getting new summary tables from your data is the combination of using the `group_by()` and `summarise()` functions together.

For example, maybe we want to know mean and sd of body mass by sex

```{r}
MeanMass <- MassSpeciesSex %>% group_by(Sex) %>% summarise(
  mean_mass = mean(Mass, na.rm = T),
  sd_mass = sd(Mass, na.rm = T)
)
```

Or maybe you want it by sex and category

```{r}
MeanMassByCat <- MassSpeciesSex %>% group_by(Category, Sex) %>% summarise(
  mean_mass = mean(Mass, na.rm = T),
  sd_mass = sd(Mass, na.rm = T)
) 
```

## Applying what you've learned

Create a new data frame from the larger data set consisting of female Douglass squirrels. Determine the mean and sd of body mass for the parental range and hybrid zone groups and save the summary results in a new data frame.

Here is a possible work-flow to answer the questions at line 133:

```{r}
DougF<-DF %>% filter(Category == "Doug" & Sex == "F") #isolates just female douglass squirrels

DougFMeans<-DougF %>% group_by(Group) %>% summarise(
  MeanMass = mean(Mass, na.rm = T),
  sdMass = sd(Mass, na.rm = T)
)
```

## If time permits, reshaping data tables.

In general, data analysis in the R framework usually wants data in what is called "long" (vs. "wide") format in which every row is a single observation and every column is a variable. Our data set is structured in that way currently. However, there are times in which certain packages require data in a "wide" format or instances in which the data come in in a wide format and need to be reshaped to long format. Reshaping of the data frame can be accomplished by two tidyverse functions, `pivot_longer()` and `pivot_wider()`

Let's look at an example.

Let's look at MassSpeciesSex

```{r}
View(MassSpeciesSex)
```

Now imagine we needed a separate column for each sex with the mass data in each column.

We would be going from long (one column indicating sex) to wide (two columns indicating sex)

We use `pivot_wider()` in the `tidyr` package to do so:

```{r}
library(tidyr)
#library(tidyverse)
MSS_wide <- MassSpeciesSex %>% pivot_wider(id_cols = c(Category,Group), id_expand = T, names_from = Sex, values_from = Mass)
View(MSS_wide)
```

And what if we wanted to reshape MSS_wide to long format by combining the M and F columns into one Sex column? We would use `pivot_longer`.

```{r}
MSS_long<-MSS_wide %>% pivot_longer(M:`F`,names_to = "Sex", values_to = "Mass")
```
